import os
import time
import json
import markdown
from datetime import datetime
from playwright.sync_api import (
    sync_playwright,
    TimeoutError as PlaywrightTimeoutError,
    expect,
)
from playwright_stealth import stealth_sync
from locators import (
    LOGIN_EMAIL_INPUT_SELECTOR,
    LOGIN_CONTINUE_BUTTON_SELECTOR,
    LOGIN_PASSWORD_INPUT_SELECTOR,
    LOGIN_SIGN_IN_BUTTON_SELECTOR,
    LOGIN_ERROR_MESSAGE_SELECTOR,
    PASSWORD_LOGIN_LINK_SELECTOR,
    DASHBOARD_INDICATOR_SELECTOR,
    NEW_POST_BUTTON_SELECTOR,
    NEW_TEXT_POST_BUTTON_SELECTOR,
    POST_TITLE_INPUT_SELECTOR,
    POST_CONTENT_EDITOR_SELECTOR,
    POST_CONTINUE_BUTTON_SELECTOR,
    SEND_BUTTON_SELECTOR,
)

import dotenv

dotenv.load_dotenv()

COOKIE_PATH = os.getenv("COOKIE_PATH", "substack_cookies_test.json")

# --- Configuration ---
# Load credentials securely from environment variables
SUBSTACK_EMAIL = os.environ.get("SUBSTACK_EMAIL")
SUBSTACK_PASSWORD = os.environ.get("SUBSTACK_PASSWORD")

# Dashboard URL from environment
SUBSTACK_URL = os.environ.get("SUBSTACK_URL")

# --- Content (Generated by your LLM) ---
TITLE = f"{datetime.now().strftime('%B %d, %Y')}Daily News Summary"
CONTENT = """
# Daily News Summary

Today we launched **Playwright** automation for Substack login with password flow.

- This summary uses `code` formatting for inline highlights.
- It also supports *italic* text and **bold** emphasis.

> “Automation saves time and reduces errors.” – Anonymous

For more details, visit [Substack](https://substack.com).
"""


def safe_locator(page, selector, name=None, timeout=30000):
    try:
        loc = page.locator(selector)
        expect(loc).to_be_visible(timeout=timeout)
        print(f"Found {name or selector}")
        return loc
    except PlaywrightTimeoutError:
        print(f"Not found {name or selector}")
        return None


def click_element(
    page, selector, name=None, visible_timeout=20000, enabled_timeout=5000
):
    """Wait for page idle, element visible & enabled, then click."""
    page.wait_for_load_state("networkidle", timeout=visible_timeout)
    el = page.locator(selector)
    el.wait_for(state="visible", timeout=visible_timeout)
    # ensure element is enabled (clickable)
    expect(el).to_be_enabled(timeout=enabled_timeout)
    print(f"Clicking {name or selector}")
    el.click()
    return el


def load_cookies(context):
    # Read cookie path from environment
    cookies_path = os.getenv("COOKIE_PATH", COOKIE_PATH)
    """Load cookies from a JSON mapping into the given browser context."""
    if not os.path.exists(cookies_path):
        print(f"No cookie file found at {cookies_path}, skipping cookies load.")
        return

    with open(cookies_path, "r") as f:
        cookie_dict = json.load(f)

    cookies = []
    for name, value in cookie_dict.items():
        cookies.append(
            {
                "name": name,
                "value": value,
                "domain": ".substack.com",
                "path": "/",
            }
        )

    context.add_cookies(cookies)
    print(f"Loaded {len(cookies)} cookies from {cookies_path}")


def inject_markdown_to_editor(page, editor_selector, markdown_text):
    """Convert markdown to HTML and inject into the ProseMirror editor."""
    html = markdown.markdown(markdown_text)
    editor = page.locator(editor_selector)
    expect(editor).to_be_visible(timeout=30000)
    editor.evaluate("(node, html) => node.innerHTML = html", html)
    print("Injected HTML content into editor.")


def launch_browser_context(playwright):
    """Start browser and context, load cookies."""
    # Determine headless flag
    headless_flag = os.getenv("HEADLESS", "true").lower() in ("true", "1", "yes")
    print(f"Headless mode: {headless_flag}")

    browser = playwright.chromium.launch(
        headless=headless_flag,
        slow_mo=50 if not headless_flag else 0,
    )
    # Create context with realistic settings
    context = browser.new_context(
        user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36",
        viewport={"width": 800, "height": 600},
        locale="en-US",
        timezone_id="America/New_York",
        permissions=["geolocation"],
    )
    load_cookies(context)
    return browser, context


def init_page(context):
    """Open a new page."""
    page = context.new_page()
    # apply stealth only in headless mode
    if os.getenv("HEADLESS", "true").lower() in ("true", "1", "yes"):
        print("Applying stealth patches to page...")
        stealth_sync(page)
    return page


def navigate_to_dashboard(page):
    """Navigate to Substack dashboard and return login status."""
    if not SUBSTACK_URL:
        print("Error: SUBSTACK_DASHBOARD_URL not set in .env")
        return False
    dashboard_path = os.path.join(SUBSTACK_URL, "publish", "home")
    print(f"Navigating to Dashboard: {dashboard_path}")
    page.goto(dashboard_path, wait_until="networkidle")
    # indicator = safe_locator(
    #     page, NEW_POST_BUTTON_SELECTOR, "New post button", timeout=30000
    # )
    indicator = True
    return bool(indicator)


def create_draft(page, title, content):
    # # ensure page is fully loaded before interacting
    # page.wait_for_load_state("networkidle", timeout=60000)
    # """Steps 3 & 4: Navigate to new post page and inject content."""
    # print("Navigating to create new post...")
    # click_element(page, NEW_POST_BUTTON_SELECTOR, "New post")
    # print("Navigating to new text post...")
    # click_element(page, NEW_TEXT_POST_BUTTON_SELECTOR, "Text post")

    print("Navigating to new post page directly...")
    page.goto(
        os.path.join(
            SUBSTACK_URL, "publish", "post?type=newsletter&back=%2Fpublish%2Fposts"
        ),
        wait_until="networkidle",
    )

    print("Waiting for editor to load...")
    title_input = safe_locator(
        page, POST_TITLE_INPUT_SELECTOR, "Post title input", timeout=30000
    )
    if not title_input:
        return

    print(f"Entering title: {title}")
    title_input.fill(title)

    print("Injecting formatted HTML content into editor...")
    inject_markdown_to_editor(page, POST_CONTENT_EDITOR_SELECTOR, content)
    print("Content entered. Waiting briefly to allow autosave...")
    time.sleep(5)
    print("\nProcess Complete. Draft should be created in Substack.")
    print("Please manually review and publish the draft via the Substack website.")


def publish_draft(page):
    print("Clicking 'Continue' button...")
    click_element(
        page,
        POST_CONTINUE_BUTTON_SELECTOR,
        "publish continue button",
        visible_timeout=50000,
    )

    print("Waiting for publish confirmation (Send button)...")
    click_element(page, SEND_BUTTON_SELECTOR, "send button", visible_timeout=50000)
    print("Draft published successfully.")


def perform_login(page):
    # click on the "Sign in with password" link
    print("Clicking 'Sign in with password' link (if applicable)...")
    try:
        click_element(
            page,
            PASSWORD_LOGIN_LINK_SELECTOR,
            "password login link",
            visible_timeout=5000,
        )
    except Exception:
        print("Password login link not found, skipping.")

    print(f"Entering email: {SUBSTACK_EMAIL}")
    email_input = safe_locator(page, LOGIN_EMAIL_INPUT_SELECTOR, "email input")
    if email_input:
        email_input.fill(SUBSTACK_EMAIL)

    # Check if clicking "Continue" reveals password field or if it's already there
    # Scenario 1: Password field appears after clicking Continue
    print("Clicking 'Continue' (if applicable)...")
    try:
        click_element(
            page,
            LOGIN_CONTINUE_BUTTON_SELECTOR,
            "login continue button",
            visible_timeout=5000,
        )
    except Exception:
        print("Continue button not found, skipping.")

    print("Entering password...")
    password_input = safe_locator(page, LOGIN_PASSWORD_INPUT_SELECTOR, "password input")
    if password_input:
        password_input.fill(SUBSTACK_PASSWORD)

    # Move the earlier continue code here
    # Check if clicking "Continue" reveals password field or if it's already there
    # Scenario 1: Password field appears after clicking Continue
    print("Clicking 'Continue' (if applicable)...")
    try:
        click_element(
            page,
            LOGIN_CONTINUE_BUTTON_SELECTOR,
            "login continue button",
            visible_timeout=5000,
        )
    except Exception:
        print("Continue button not found, skipping.")

    print("Waiting for login confirmation (Dashboard indicator)...")
    # Wait for navigation to complete and dashboard element to appear
    # Important: If login fails (bad password, CAPTCHA), this will likely time out.
    try:
        logged_in_element = page.locator(DASHBOARD_INDICATOR_SELECTOR)
        # Use a longer timeout as login redirects can take time
        expect(logged_in_element).to_be_visible(timeout=30000)  # Wait up to 30s
        print("Login successful (Dashboard element detected).")
    except PlaywrightTimeoutError:
        print("\nError: Timed out waiting for dashboard element after login.")
        # Check for common failure indicators
        try:
            error_msg = page.locator(LOGIN_ERROR_MESSAGE_SELECTOR).text_content(
                timeout=2000
            )
            print(f"Possible login error detected: {error_msg}")
        except PlaywrightTimeoutError:
            print("Could not find dashboard element OR specific error message.")
            print(
                "Login may have failed due to invalid credentials, CAPTCHA, 2FA, or UI changes."
            )
        raise  # Re-raise the timeout error to stop execution


def post_substack_draft(title=TITLE, content=CONTENT):
    if not SUBSTACK_EMAIL or not SUBSTACK_PASSWORD:
        print(
            "Error: SUBSTACK_EMAIL and SUBSTACK_PASSWORD environment variables must be set."
        )
        return

    with sync_playwright() as p:
        browser, context = launch_browser_context(p)
        page = init_page(context)

        try:
            logged_in = navigate_to_dashboard(page)
            if not logged_in:
                perform_login(page)
                # Re-check access after login
                logged_in = navigate_to_dashboard(page)
                if not logged_in:
                    print("Error: Login failed, cannot access dashboard.")
                    return
            create_draft(page, title, content)
            # publish_draft(page)

        except PlaywrightTimeoutError as e:
            print(f"\nPlaywright Error: Timed out waiting for an element: {e}")
            print("The Substack UI might have changed, or the element took too long.")
            print("Check if a CAPTCHA appeared.")
            page.screenshot(path="playwright_error_screenshot.png")
            print("Screenshot saved as playwright_error_screenshot.png")
        except Exception as e:
            print(f"\nAn unexpected error occurred: {e}")
            page.screenshot(path="playwright_error_screenshot.png")
            print("Screenshot saved as playwright_error_screenshot.png")
        finally:
            time.sleep(5)
            print("Closing browser.")
            browser.close()


# --- Run the Automation ---
if __name__ == "__main__":
    post_substack_draft()
