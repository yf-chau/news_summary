import os
import time
import json
import markdown
from playwright.sync_api import (
    sync_playwright,
    TimeoutError as PlaywrightTimeoutError,
    expect,
)

# --- Configuration ---
# Load credentials securely from environment variables
SUBSTACK_EMAIL = os.environ.get("SUBSTACK_EMAIL")
SUBSTACK_PASSWORD = os.environ.get("SUBSTACK_PASSWORD")

# --- Content (Generated by your LLM) ---
daily_title = "Daily News Summary - April 24, 2025 (Password Login)"
daily_summary_content = """
# Daily News Summary

Today we launched **Playwright** automation for Substack login with password flow.

- This summary uses `code` formatting for inline highlights.
- It also supports *italic* text and **bold** emphasis.

> “Automation saves time and reduces errors.” – Anonymous

For more details, visit [Substack](https://substack.com).
"""

# --- Locators (PLACEHOLDERS - UPDATE THESE!) ---
# You MUST inspect Substack's HTML and update these selectors
# Login Page
LOGIN_EMAIL_INPUT_SELECTOR = "input[type='email'][name='email']"  # Example
LOGIN_CONTINUE_BUTTON_SELECTOR = "role=button[name='Continue']"
LOGIN_PASSWORD_INPUT_SELECTOR = "input[type='password'][name='password']"  # Example
LOGIN_SIGN_IN_BUTTON_SELECTOR = (
    "role=button[name='Sign in']"  # Example (final login button)
)
# Optional: Selector for error messages if login fails
LOGIN_ERROR_MESSAGE_SELECTOR = "div.error-message"  # Example

# Post-Login / Dashboard
DASHBOARD_INDICATOR_SELECTOR = (
    "button[data-href*='/publish/home']:has-text('Dashboard')"
)
NEW_POST_BUTTON_SELECTOR = "button:has-text('New post')"
NEW_TEXT_POST_BUTTON_SELECTOR = "role=link[name='Text post']"

# Editor Page
POST_TITLE_INPUT_SELECTOR = "textarea[placeholder='Title']"  # Example
POST_CONTENT_EDITOR_SELECTOR = (
    "div.tiptap.ProseMirror"  # Example: VERY LIKELY TO CHANGE
)


def load_cookies(context, cookies_path="substack_cookies.json"):
    """Load cookies from a JSON mapping into the given browser context."""
    if not os.path.exists(cookies_path):
        print(f"No cookie file found at {cookies_path}, skipping cookies load.")
        return

    with open(cookies_path, "r") as f:
        cookie_dict = json.load(f)

    cookies = []
    for name, value in cookie_dict.items():
        cookies.append(
            {
                "name": name,
                "value": value,
                "domain": ".substack.com",
                "path": "/",
            }
        )

    context.add_cookies(cookies)
    print(f"Loaded {len(cookies)} cookies from {cookies_path}")


def perform_login(page):
    # click on the "Sign in with email" link
    print("Clicking 'Sign in with password' link (if applicable)...")
    email_login_link = page.locator(
        "a.login-option.substack-login__login-option:has-text('Sign in with password')"
    )
    if email_login_link.is_visible(timeout=5000):
        email_login_link.click()

    print(f"Entering email: {SUBSTACK_EMAIL}")
    email_input = page.locator(LOGIN_EMAIL_INPUT_SELECTOR)
    expect(email_input).to_be_visible(timeout=15000)
    email_input.fill(SUBSTACK_EMAIL)

    # Check if clicking "Continue" reveals password field or if it's already there
    # Scenario 1: Password field appears after clicking Continue
    print("Clicking 'Continue' (if applicable)...")
    continue_button = page.locator(LOGIN_CONTINUE_BUTTON_SELECTOR)
    if continue_button.is_visible(timeout=5000):  # Check if continue button exists
        expect(continue_button).to_be_enabled()
        continue_button.click()
        # Wait a moment for potential password field to appear
        time.sleep(1)
    else:
        print("'Continue' button not found or not needed, proceeding...")

    print("Entering password...")
    password_input = page.locator(LOGIN_PASSWORD_INPUT_SELECTOR)
    # Add extra wait here in case the password field loads slower
    expect(password_input).to_be_visible(timeout=15000)
    password_input.fill(SUBSTACK_PASSWORD)

    # Move the earlier continue code here
    # Check if clicking "Continue" reveals password field or if it's already there
    # Scenario 1: Password field appears after clicking Continue
    print("Clicking 'Continue' (if applicable)...")
    continue_button = page.locator(LOGIN_CONTINUE_BUTTON_SELECTOR)
    if continue_button.is_visible(timeout=5000):  # Check if continue button exists
        expect(continue_button).to_be_enabled()
        continue_button.click()
        # Wait a moment for potential password field to appear
        time.sleep(1)
    else:
        print("'Continue' button not found or not needed, proceeding...")

    print("Waiting for login confirmation (Dashboard indicator)...")
    # Wait for navigation to complete and dashboard element to appear
    # Important: If login fails (bad password, CAPTCHA), this will likely time out.
    try:
        logged_in_element = page.locator(DASHBOARD_INDICATOR_SELECTOR)
        # Use a longer timeout as login redirects can take time
        expect(logged_in_element).to_be_visible(timeout=30000)  # Wait up to 30s
        print("Login successful (Dashboard element detected).")
    except PlaywrightTimeoutError:
        print("\nError: Timed out waiting for dashboard element after login.")
        # Check for common failure indicators
        try:
            error_msg = page.locator(LOGIN_ERROR_MESSAGE_SELECTOR).text_content(
                timeout=2000
            )
            print(f"Possible login error detected: {error_msg}")
        except PlaywrightTimeoutError:
            print("Could not find dashboard element OR specific error message.")
            print(
                "Login may have failed due to invalid credentials, CAPTCHA, 2FA, or UI changes."
            )
        raise  # Re-raise the timeout error to stop execution


def inject_markdown_to_editor(page, editor_selector, markdown_text):
    """Convert markdown to HTML and inject into the ProseMirror editor."""
    html = markdown.markdown(markdown_text)
    editor = page.locator(editor_selector)
    expect(editor).to_be_visible(timeout=15000)
    editor.evaluate("(node, html) => node.innerHTML = html", html)
    print("Injected HTML content into editor.")


def run_substack_automation_password():
    if not SUBSTACK_EMAIL or not SUBSTACK_PASSWORD:
        print(
            "Error: SUBSTACK_EMAIL and SUBSTACK_PASSWORD environment variables must be set."
        )
        return

    with sync_playwright() as p:
        browser = p.chromium.launch(headless=False, slow_mo=50)
        context = browser.new_context()
        load_cookies(context)
        page = context.new_page()

        try:
            print("Navigating to Dashboard...")
            page.goto(
                "https://hknewsdigest.substack.com/publish/home",
                wait_until="domcontentloaded",
            )

            if not page.locator(DASHBOARD_INDICATOR_SELECTOR).is_visible(timeout=15000):
                perform_login(page)

            # --- Create Draft (Same as before) ---
            print("Navigating to create new post...")
            new_post_button = page.locator(NEW_POST_BUTTON_SELECTOR)
            expect(new_post_button).to_be_visible(timeout=15000)
            new_post_button.click()

            new_text_post_button = page.locator(NEW_TEXT_POST_BUTTON_SELECTOR)
            expect(new_text_post_button).to_be_visible(timeout=15000)
            new_text_post_button.click()

            print("Waiting for editor to load...")
            title_input = page.locator(POST_TITLE_INPUT_SELECTOR)
            expect(title_input).to_be_visible(timeout=20000)

            print(f"Entering title: {daily_title}")
            title_input.fill(daily_title)

            print("Injecting formatted HTML content into editor...")
            # inject_markdown_to_editor(
            #     page, POST_CONTENT_EDITOR_SELECTOR, daily_summary_content
            # )
            daily_summary_content = open(
                "/Users/yaufai.chau/code/news_summary/temp/summary-1_edited.md"
            ).read()
            inject_markdown_to_editor(
                page, POST_CONTENT_EDITOR_SELECTOR, daily_summary_content
            )

            print("Content entered. Waiting briefly to allow autosave...")
            time.sleep(5)

            print("\nProcess Complete. Draft should be created in Substack.")
            print(
                "Please manually review and publish the draft via the Substack website."
            )

        except PlaywrightTimeoutError as e:
            print(f"\nPlaywright Error: Timed out waiting for an element: {e}")
            print("The Substack UI might have changed, or the element took too long.")
            print("Check if a CAPTCHA appeared.")
            page.screenshot(path="playwright_error_screenshot.png")
            print("Screenshot saved as playwright_error_screenshot.png")
        except Exception as e:
            print(f"\nAn unexpected error occurred: {e}")
            page.screenshot(path="playwright_error_screenshot.png")
            print("Screenshot saved as playwright_error_screenshot.png")
        finally:
            print("Closing browser.")
            browser.close()


# --- Run the Automation ---
if __name__ == "__main__":
    run_substack_automation_password()
